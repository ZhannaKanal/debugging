JavaScript Errors

A SyntaxError happens when you write something incorrectly in your code, like missing a paranthesis, or a bracket. Think of it like a grammar mistake in a sentence. 
const arr = ["Beau", "Quincy" "Tom"] // each array element needs to be separated by a comma otherwise it will result in an error message.

A ReferenceError has several reasons, first of it would be not defined variables.
console.log(price); // Reference error
we want log price var, but it hasnt been defined.
Another is trying to access a variable, declared with const and let, before it has been defined.
console.log(b);
const b = 50;
result Cannot access "b" before initialization.
Third is TypeError occur when you try to perform an operation on the wrong type.
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};
developerObj.map()
result developerObj.map is not a function, cause map method is used for arrays, not objects
Last is RangeError happens when your code tries to use a value that's outside the range of what JS can handle. 
const arr = [];
arr.length = -1; 
since array's length has to be a non-negative integer, setting it to -1 triggers a RangeError.

Throw Statement 
is used to throw a user defined exception.
An exception in programming, is when an unexpected event happens and disrupts the normal flow of the program.
Basic Syntax:
throw expression;
The excetion inthis case would be the object or value that represents the exception you want to throw.
Example of this would be the build in exception classes like the Error, TypeError or RangeError class.
function validateNumber(input){
  if(typeof input !== "number"){
    throw new TypeError("Expected a number, but recieved " + typeof input);
  }
  return input * 2;
}

function divide(numerator, denominator){
  if(denominator === 0){
    throw new Error("Cannot divide by zero");
  }
  return numerator / denominator;
}

try...catch...finally
The try block is used to wrap code that might throw an error.
It acts as a safe space to try something that could fail.
The catch block captures and handles errors that occur in the try block.
You can use the Error object inside catch to inspect what went wrong.
The finally block runs after the try and catch blocks, regardless of whether an error occured.
It's commonly used for cleanup tasks, such as closing files or releasing resources.

function processInput(input){
  if(typeof input !== "string"){
    throw new TypeError("Input must be a string.")
  }

  return input.toUpperCase();
}
try{
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
}catch(error){
  console.error("Error occured:", error.message);
}

A good use case for the finally statement is if you were working with files.
In Js, you can open a file, use a try block to write data to the file. 
If there are any errors, you can use the catch to catch those errors. 
Then use the finally statement to close the file.

Debugger Statement
is a powerful JS tool that lets you pause your code at a specific line to investigate what's going on in the program. 
When used correctly, the debugger statement can save you a lot of time trying to figure out why something is not working as it should.
JS executes your code from top to bottom. 
While JS executes your code and hits a debugger statement, it immediately pauses execution at that line.
This gives you the chance to inspect variables, check functions, and the flow of the code in general.
To use debugger statement your browser's developer tool should be open, otherwise the statement is ignored, and the code continues to run as usual.
let firstNumber = 5;
let secondNumber = 10;
debugger; // Code execution pauses here
let sum = firstNumber+secondNumber;
console.log(sum)
//if you don't have console open before code runs, it returns 15, otherwise the execution is paused for you, so you can inspect the code.
