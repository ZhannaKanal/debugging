JavaScript Errors

A SyntaxError happens when you write something incorrectly in your code, like missing a paranthesis, or a bracket. Think of it like a grammar mistake in a sentence. 
const arr = ["Beau", "Quincy" "Tom"] // each array element needs to be separated by a comma otherwise it will result in an error message.

A ReferenceError has several reasons, first of it would be not defined variables.
console.log(price); // Reference error
we want log price var, but it hasnt been defined.
Another is trying to access a variable, declared with const and let, before it has been defined.
console.log(b);
const b = 50;
result Cannot access "b" before initialization.
Third is TypeError occur when you try to perform an operation on the wrong type.
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};
developerObj.map()
result developerObj.map is not a function, cause map method is used for arrays, not objects
Last is RangeError happens when your code tries to use a value that's outside the range of what JS can handle. 
const arr = [];
arr.length = -1; 
since array's length has to be a non-negative integer, setting it to -1 triggers a RangeError.

Throw Statement 
is used to throw a user defined exception.
An exception in programming, is when an unexpected event happens and disrupts the normal flow of the program.
Basic Syntax:
throw expression;
The excetion inthis case would be the object or value that represents the exception you want to throw.
Example of this would be the build in exception classes like the Error, TypeError or RangeError class.
function validateNumber(input){
  if(typeof input !== "number"){
    throw new TypeError("Expected a number, but recieved " + typeof input);
  }
  return input * 2;
}

function divide(numerator, denominator){
  if(denominator === 0){
    throw new Error("Cannot divide by zero");
  }
  return numerator / denominator;
}

try...catch...finally
The try block is used to wrap code that might throw an error.
It acts as a safe space to try something that could fail.
The catch block captures and handles errors that occur in the try block.
You can use the Error object inside catch to inspect what went wrong.
The finally block runs after the try and catch blocks, regardless of whether an error occured.
It's commonly used for cleanup tasks, such as closing files or releasing resources.

function processInput(input){
  if(typeof input !== "string"){
    throw new TypeError("Input must be a string.")
  }

  return input.toUpperCase();
}
try{
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
}catch(error){
  console.error("Error occured:", error.message);
}

A good use case for the finally statement is if you were working with files.
In Js, you can open a file, use a try block to write data to the file. 
If there are any errors, you can use the catch to catch those errors. 
Then use the finally statement to close the file.

Debugger Statement
is a powerful JS tool that lets you pause your code at a specific line to investigate what's going on in the program. 
When used correctly, the debugger statement can save you a lot of time trying to figure out why something is not working as it should.
JS executes your code from top to bottom. 
While JS executes your code and hits a debugger statement, it immediately pauses execution at that line.
This gives you the chance to inspect variables, check functions, and the flow of the code in general.
To use debugger statement your browser's developer tool should be open, otherwise the statement is ignored, and the code continues to run as usual.
let firstNumber = 5;
let secondNumber = 10;
debugger; // Code execution pauses here
let sum = firstNumber+secondNumber;
console.log(sum)
//if you don't have console open before code runs, it returns 15, otherwise the execution is paused for you, so you can inspect the code.
If you reload the page with the console opened, you'll see that the page keeps reloading, confirming that the execution of the code is only paused, not stopped. If you want the execution to continue, you can click the play button

Advanced JS Debugging Tecchniques
console.log()
With Browser DevTools

Breakpoints — “pause the program”
How you use it
Open DevTools → Sources
Click the line number
Refresh page
The code stops there.

Conditional breakpoint (VERY powerful)
Pause only when condition happens.
Example:
You loop 10,000 users but bug happens only for one.
Right click → Add conditional breakpoint
user.id === 8421
Boom — jumps directly to the broken case.

Breakpoints: Breakpoints let you pause the execution of your code at a specific line of your choice. After the pause, you can inspect variables, evaluate expressions, and examine the call stack.
Watchers: Watch expressions lets you monitor the values of variables or expressions as the code runs even if they are out of the current scope.
Profiling: Profiling helps you identify performance bottlenecks by letting you capture screenshots and record CPU usage, function calls, and execution time.
console.dir(): This method is used to display an interactive list of the properties of a specified JavaScript object. It outputs a hierarchical listing that can be expanded to see all nested properties.
console.dir(document);
console.table(): This method displays tabular data as a table in the console. It takes one mandatory argument, which must be an array or an object, and one optional argument to specify which properties (columns) to display.

When to use what
Logic wrong --	Breakpoint
Rare bug --	Conditional breakpoint
Value changing --	Watch
Site slow --	Performance
API error	-- Network
Arrays --	console.table
DOM object --	console.dir